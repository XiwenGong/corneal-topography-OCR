

### 标题



《基于可配置架构的医学图像批量OCR系统设计与实现》



- 可配置架构
	- 项目支持自定义结构类型判别方案
	- 支持自定义划分识别区方案
	- 支持自定义预处理方案
	- 支持多种OCR引擎
	- 支持自定义后处理方案
	- 这些配置均保存在shared_data.pkl文件中，除可通过专门的编辑软件（项目内容之一）进行管理外，也可灵活地直接读取和修改



- 光学字符识别
	- 可以识别图片中的文字内容
	- 支持多种OCR引擎
	- 支持本地识别（Tesseract OCR）或云端识别（百度OCR API）
	- 支持批量处理多张图片
	- 支持对单张图片中的多个识别区进行批量识别



- 医学图像
	- 系统可以处理各种具有特定格式的带文字图片
	- 特别适合处理医学检查报告、诊断结果等文档
	- 目前主要应用于角膜地形图医学图像的文字识别


- 系统设计
	- 通过用例图梳理了系统的主要功能模块和用户操作流程，明确了用户与系统各部分的交互关系
	- 利用类图设计了系统的核心类及其属性、方法和类之间的关系，保证了代码结构的清晰和可扩展性
	- 采用流程图描述了图片标注、识别、数据导出等关键业务流程，帮助理清各模块的处理步骤和逻辑顺序
	- 结合时序图分析了系统在执行批量识别等典型场景下各对象之间的消息传递和时序关系，确保系统各部分协同工作
	- 整体设计遵循模块化和可配置原则，便于后续功能扩展和维护


*注：类图旧版丢失，新版待重画



- 实现
	- 使用Python语言开发，主要依赖PyQt6、OpenCV、Tesseract、requests等技术
	- 采用面向对象编程思想，核心功能通过类的方式进行封装与管理，提高了代码的可维护性和扩展性
	- 实现了图片的批量导入、标注、识别、结果导出等完整流程
	- 配置数据统一保存在shared_data.pkl文件中，便于管理和修改
	- 支持调用百度OCR等第三方API服务，扩展了系统的识别能力
	- 识别结果可自动导出为Excel文件，方便后续数据分析和利用
	- 提供了完整的用户操作界面

---

### 摘要





---


### 关键词




---


# 1. 绪论

## 1.1 研究背景与意义




角膜地形图是眼科临床诊断中的重要检查手段，它通过测量角膜表面的曲率分布，为角膜疾病的诊断和治疗提供重要依据[1]。随着医疗信息化的快速发展，大量的角膜地形图检查结果以图像形式保存，这些图像中包含了丰富的数值信息和文字标注。然而，目前对这些图像数据的处理仍主要依赖人工读取和记录，不仅效率低下，而且容易出错。因此，开发一个自动化的角膜地形图OCR（光学字符识别）系统具有重要的现实意义。

在医学图像处理领域，相关研究表明，医学图像的信息提取和自动化处理是提高医疗效率的关键环节[2]。特别是在眼科领域，角膜地形图的数据分析对于角膜疾病的早期诊断和手术规划至关重要。相关文献详细阐述了角膜地形图在临床诊断中的应用价值，强调了准确提取和记录地形图数据的重要性[3]。

随着人工智能技术的发展，OCR技术在医疗领域的应用日益广泛。现代OCR技术的基本原理和实现方法为医疗图像的文字识别提供了技术基础[4]。然而，现有的通用OCR系统在处理具有特定格式的医学图像时往往存在识别准确率不高的问题，这主要是由于医学图像的特殊性和复杂性导致的。

本项目针对角膜地形图这一特定类型的医学图像，开发了一个专门的OCR系统。该系统具有以下特点：

1. 支持自定义结构类型判别方案，可以适应不同型号角膜地形图设备的输出格式

2. 实现了灵活的识别区域划分方案，能够准确定位和提取关键数据

3. 集成了图像预处理和后处理模块，提高了识别准确率

4. 采用结构化的数据存储方式，便于后续的数据分析和应用

该系统的开发不仅能够提高角膜地形图数据的处理效率，减少人工操作带来的误差，还能为眼科临床研究提供标准化的数据支持。同时，系统的模块化设计也为其他类型医学图像的OCR处理提供了可借鉴的技术方案。

通过本项目的实施，我们期望能够：

1. 显著提高角膜地形图数据的处理效率

2. 减少人工操作带来的误差

3. 为眼科临床研究提供标准化的数据支持

4. 探索医学图像OCR处理的新方法

这些目标的实现将有助于推动眼科诊疗的信息化建设，提高医疗服务的质量和效率。同时，项目开发过程中积累的经验和技术方案，也可以为其他医学图像处理系统的开发提供参考。


---


## 1.2 国内外研究现状




---

## 1.3 系统结构简介



本系统采用双模块设计，分为方案编辑模块和识别执行模块两个核心部分。

方案编辑模块（位于scripts/bian_ji目录）是系统的配置部分，用于设置和调整识别方案。该模块允许用户根据不同的角膜地形图特征，自定义识别参数和规则。通过这个模块，用户可以灵活地调整识别策略，以适应不同类型的角膜地形图，提高识别的准确性和适应性。

识别执行模块（位于scripts/shi_bie目录）是系统的执行部分，负责实际的图像识别和数据提取工作。该模块接收经过方案编辑模块配置的参数，对放入"原始图片们"文件夹的角膜地形图进行自动识别。识别过程中，系统会调用百度OCR API进行文字识别，并将识别结果保存到results目录中。

系统还包含多个辅助工具（位于mu_ban目录），如fix_judge_names.py用于修正判断名称，view_pkl.py用于查看数据文件内容，edit_shared_data.py用于编辑共享数据等。这些工具共同确保了系统的可靠运行和数据的准确性。系统会在mu_ban目录下维护一个shared_data.pkl文件，用于存储识别过程中的共享数据和配置信息。


---

## 1.4 使用方法



为方便用户使用，系统已经打包成可执行文件（.exe），用户无需安装Python环境即可直接运行。打包后的程序保留了所有功能模块，并进行了优化，确保运行效率和稳定性。


系统使用时主要分为方案编辑和图像识别两个阶段。

在方案编辑阶段，用户首先启动系统，进入方案编辑模块，根据待识别的角膜地形图特征设置相应的识别参数，可以保存多个不同的识别方案以应对不同类型的图像。

在图像识别阶段，用户只需将需要识别的角膜地形图放入"原始图片们"文件夹，在识别执行模块中选择要使用的识别方案，系统就会自动进行图像处理和OCR识别，并实时原位显示识别结果，之后用户可以点击按钮将识别结果以excel表格形式保存在results文件夹中。


这种双模块设计使得系统既保持了使用的简便性，又具备了足够的灵活性。用户可以通过方案编辑模块不断优化识别方案，而识别执行模块则确保这些方案能够被准确执行，为眼科检查数据的处理提供了可靠的技术支持。


----

# 2. 主要原理与技术



---

## 2.1 光学字符识别技术


光学字符识别（Optical Character Recognition，OCR）是一种将图像中的文字转换为可编辑文本的技术。在角膜地形图检查中，OCR技术被用于识别检查报告中的各项参数和数值，为眼科医生提供快速、准确的数据支持。本系统针对角膜地形图的特点，采用了多引擎协同的OCR方案，通过灵活的配置和优化，实现了高效准确的文字识别。

### 2.1.1 技术发展历程


OCR技术的发展经历了从基于模板匹配到基于深度学习的重大变革。本系统采用的两种OCR引擎代表了不同阶段的技术特点：Tesseract OCR作为开源引擎，采用了传统的特征提取和模式识别方法，具有较好的通用性和可扩展性；百度OCR API则采用了最新的深度学习技术，通过大规模数据训练，在识别准确率上具有明显优势。系统通过配置文件（shared_data.pkl）统一管理这两种引擎，用户可以根据实际需求灵活选择，在保证识别准确率的同时，兼顾系统的可用性和成本效益。


### 2.1.2 核心技术原理



本系统的OCR实现基于完整的图像处理流程。首先，系统通过图像预处理提高文字区域的可识别性，预处理方案通过代码字符串配置，支持各种OpenCV操作，包括图像增强、噪声去除等。然后，系统根据配置的区域坐标信息（存储在pkl3和pkl5中）进行文字定位，提取感兴趣区域（ROI）。对于每个识别区域，系统都会执行特定的预处理方案，可能包括图像增强、噪声去除等操作。预处理完成后，系统根据配置选择OCR引擎进行文字识别。百度OCR API通过HTTP请求发送base64编码的图像数据，返回JSON格式的识别结果；Tesseract OCR则直接在本地进行识别，支持中英文混合识别。最后，系统对识别结果进行后处理，后处理方案同样通过代码字符串配置，可以对识别文本进行清理、格式调整等操作。



### 2.1.3 应用场景与挑战



在角膜地形图识别中，系统面临着特殊的挑战。首先，角膜地形图包含大量的专业术语和数值，需要专门的训练数据；其次，检查报告的格式多样，包括表格、图表等复杂结构；此外，医疗文档对识别准确率要求极高，因为任何错误都可能影响医疗决策。针对这些挑战，系统采用了多引擎协同、后处理优化等策略。通过百度OCR API和Tesseract OCR的协同工作，系统能够处理各种复杂的文字识别任务。百度OCR API基于深度学习，具有较高的识别准确率，支持中英文混合识别，适合处理复杂的文字场景；Tesseract OCR作为开源引擎，提供了本地化的文字识别能力，可以在离线环境下使用，适合处理简单的文字场景。系统通过灵活的配置方式，使得用户可以根据实际需求选择最适合的OCR引擎，在保证识别准确率的同时，兼顾系统的可用性和成本效益。


### 2.1.4 本系统中的实现方案



本系统在文字识别方面采用了双引擎架构，同时支持百度OCR API和Tesseract OCR两种识别引擎。百度OCR API是基于深度学习的商业级OCR服务，通过REST API接口提供服务，支持中英文混合识别，具有较高的识别准确率。系统通过配置文件（baidu_ocr_key.txt）管理API密钥，使用access_token进行身份验证。Tesseract OCR作为开源OCR引擎，提供了本地化的文字识别能力，支持中英文识别（通过lang='chi_sim+eng'参数配置），可以在离线环境下使用。系统通过OCR_ENGINES字典统一管理这两种引擎，用户可以根据实际需求在配置界面灵活选择不同的OCR引擎，在保证识别准确率的同时，兼顾系统的可用性和成本效益。


系统的OCR技术实现基于完整的图像处理流程。首先，系统通过图像预处理提高文字区域的可识别性，预处理方案通过代码字符串配置，支持各种OpenCV操作。然后，系统根据配置的区域坐标信息（存储在pkl3和pkl5中）进行文字定位，提取感兴趣区域（ROI）。对于每个识别区域，系统都会执行特定的预处理方案，可能包括图像增强、噪声去除等操作。预处理完成后，系统根据配置选择OCR引擎进行文字识别。百度OCR API通过HTTP请求发送base64编码的图像数据，返回JSON格式的识别结果；Tesseract OCR则直接在本地进行识别，支持中英文混合识别。最后，系统对识别结果进行后处理，后处理方案同样通过代码字符串配置，可以对识别文本进行清理、格式调整等操作。这种灵活的配置方式使得系统能够适应不同的识别场景，通过多引擎的支持提高系统的适应性和可靠性。


----

## 2.2 图像处理技术



本系统在图像处理方面主要采用OpenCV（Open Source Computer Vision Library）进行基础图像操作。系统通过配置文件（shared_data.pkl）来管理不同区域的图像处理方案，主要包括以下功能：

### 2.2.1 基础图像操作

系统使用OpenCV进行基础的图像操作，主要包括图像的读取、颜色空间转换和编码。在图像读取方面，系统使用cv2.imread()函数读取各种格式的图像文件（支持jpg、jpeg、png、bmp、gif、tiff、webp等格式）。为了适应不同的处理需求，系统使用cv2.cvtColor()函数进行BGR到RGB的颜色空间转换，这对于某些图像处理操作和OCR识别是必要的。此外，系统还使用cv2.imencode()函数将图像转换为base64格式，这是为了满足百度OCR API的调用要求。

### 2.2.2 区域处理

系统的区域处理功能分为两个层次：基本类型区域和自定义区域。基本类型区域包括basic_type_1到basic_type_4四种类型，这些是系统预设的标准区域类型。自定义区域则是在pkl5配置文件中定义的特殊区域，可以根据具体需求进行灵活配置。每个区域都可以独立配置三个关键参数：预处理方案、OCR引擎选择和后处理方案。预处理方案通过代码字符串定义，可以包含任何OpenCV支持的图像处理操作；OCR引擎选择支持tesseractOCR和百度OCR两种选项；后处理方案则用于对OCR识别结果进行文本处理，提高识别准确率。

### 2.2.3 图像处理流程

系统的图像处理流程是一个完整的处理链，从图像输入到最终结果输出。首先，系统根据预定义的判别方案（存储在pkl2中）对输入图像进行分类，确定图像的类型。然后，根据配置的坐标信息提取感兴趣区域（ROI），这些区域包含了需要识别的文字信息。接着，系统执行区域特定的预处理方案，可能包括图像增强、噪声去除等操作。预处理完成后，系统使用选定的OCR引擎（tesseractOCR或百度OCR）进行文字识别。最后，系统对识别结果进行后处理，包括文本清理、格式调整等操作，以提高最终结果的可用性。

### 2.2.4 配置管理

系统的配置管理采用集中化的方式，通过shared_data.pkl文件统一管理所有配置信息。这个配置文件分为四个主要部分：pkl2存储图像类型判别方案，用于确定图像的类型；pkl3存储区域标注信息，定义了各个识别区域的位置和属性；pkl4存储OCR方案配置，包括预处理、后处理方案和OCR引擎选择；pkl5存储自定义区域配置，允许用户定义特殊的识别区域。这种配置管理方式使得系统具有很好的灵活性，用户可以通过编辑配置文件来调整图像处理方案，而不需要修改代码。预处理和后处理方案都支持自定义代码，用户可以根据实际需求进行图像增强、噪声去除等操作，使系统能够适应各种不同的应用场景。





---

## 2.3 用户界面技术



本系统采用PyQt6框架构建图形用户界面，这是一个功能强大的GUI框架。系统包含多个功能模块，每个模块都有其专门的界面设计，主要包括图片标注界面、OCR方案编辑界面、识别结果显示界面等。这些界面都遵循统一的设计原则，确保用户体验的一致性和易用性。

### 2.3.1 界面组件设计


系统使用了PyQt6提供的丰富界面组件，包括标签（QLabel）、按钮（QPushButton）、文本框（QTextEdit）、下拉框（QComboBox）等。在图片标注界面中，系统实现了图片拖拽功能，支持图片自适应窗口大小，并在右下角实时显示图片显示尺寸。在OCR方案编辑界面中，系统提供了OCR引擎选择、预处理方案和后处理方案的编辑功能，使用户能够灵活配置识别参数。在识别结果显示界面中，系统实现了图片浏览和结果展示功能，支持上一张/下一张切换，并提供了保存功能。


### 2.3.2 事件处理机制


系统采用事件驱动编程模式，通过信号槽机制实现界面交互。例如，在图片标注界面中，系统通过重写dragEnterEvent和dropEvent方法实现文件拖拽功能；在OCR方案编辑界面中，通过按钮的clicked信号触发保存操作；在识别结果显示界面中，通过按钮点击事件实现图片切换和结果保存。系统还实现了多线程处理，通过QApplication.processEvents()确保界面在长时间操作时保持响应，避免界面卡顿。

### 2.3.3 界面布局与样式


系统的界面布局采用垂直布局（QVBoxLayout）和水平布局（QHBoxLayout）相结合的方式，确保界面元素排列合理，操作便捷。界面样式设计注重简洁性和可读性，使用统一的字体（Consolas）和合适的字体大小，确保文字清晰可辨。系统还实现了窗口置顶、窗口大小调整等功能，提升用户体验。在错误处理方面，系统通过消息框（QMessageBox）提供友好的错误提示，帮助用户理解和解决问题。

### 2.3.4 交互设计优化


系统在交互设计上进行了多项优化。首先，系统支持图片拖拽操作，用户可以直接将图片拖入窗口进行处理，无需通过文件选择对话框。其次，系统实现了图片自适应显示，自动调整图片大小以适应窗口，并保持图片比例。再次，系统提供了实时进度显示功能，通过进度条和文本显示当前处理进度，让用户了解处理状态。最后，系统实现了配置的保存和加载功能，用户可以保存当前的配置，下次使用时自动加载，提高使用效率。

---

## 2.4 数据处理与系统集成



### 2.4.1 数据存储方案


本系统采用多层次的数据存储和管理方案，确保数据的安全性和可靠性。在数据存储方面，系统实现了三种主要的数据存储方式。首先，系统使用文件系统存储原始图像和处理结果，原始图像存储在"原始图片们"目录中，处理后的图像保存在"结果"目录中，临时文件则存放在"lin_shi"目录下，这种存储方式便于用户直接访问和管理图像文件。其次，系统使用Python的pickle模块实现配置数据的序列化存储，通过DataManager类管理所有配置数据，将数据以字典结构保存在shared_data.pkl文件中，每个配置项都包含时间戳信息，便于追踪数据的修改历史。此外，系统还支持将识别结果导出为Excel文件，方便用户进行数据分析和统计，导出的Excel文件包含完整的识别结果，包括图像路径、识别文本、置信度等信息。

### 2.4.2 数据管理机制

在数据管理方面，系统实现了多项核心功能以确保数据的可靠性和安全性。系统在保存数据时进行数据验证，确保必要字段不为空，例如在保存OCR方案时，系统会检查预处理方案和后处理方案是否为空，防止保存无效数据。同时，系统使用DataManager类统一管理所有数据操作，确保数据的一致性，每个数据操作都通过save_data和get_data方法进行，避免数据不一致的问题。此外，系统还实现了数据备份机制，在覆盖已有数据时会提示用户确认，防止意外数据丢失，并使用异常处理机制捕获数据操作过程中的错误，确保数据操作的可靠性。

### 2.4.3 系统模块划分



在系统集成方面，系统采用模块化设计原则，将功能划分为多个独立的模块，每个模块负责特定的功能。图像处理模块负责图像的预处理、增强和分割等操作，使用OpenCV库实现各种图像处理算法；OCR识别模块支持多种OCR引擎（Tesseract和百度OCR），实现文本识别功能，并提供预处理和后处理方案配置；用户界面模块使用PyQt6构建图形用户界面，包括图片标注界面、OCR方案编辑界面、识别结果显示界面等；数据管理模块通过DataManager类统一管理所有数据操作，实现数据的存储、读取和更新。

### 2.4.4 模块化设计原则


在模块化设计方面，系统遵循高内聚、低耦合、可扩展性和可维护性的原则。每个模块都有明确的职责，例如ImageWindow类专门负责图片显示和尺寸调整，OCREditWindow类专门负责OCR方案编辑，体现了高内聚原则。模块之间通过接口进行通信，例如DataManager类提供统一的数据访问接口，其他模块通过这个接口访问数据，而不直接操作数据文件，实现了低耦合。系统设计支持添加新的功能模块，例如可以方便地添加新的OCR引擎或图像处理算法，保证了可扩展性。每个模块都有清晰的代码结构和注释，便于理解和修改，系统使用JSDoc风格的注释，详细说明每个类和方法的用途和参数，提高了可维护性。


### 2.4.5 性能优化策略


在性能优化方面，系统采用了多线程技术以显著提升整体性能，涵盖了界面响应、图像处理和数据读写等多个关键环节。具体来说，系统在批量识别和处理图片时，将耗时的图像识别任务放入后台线程（如QThread）中执行，主线程则专注于界面显示和进度更新。这样一来，即使在处理大量图片时，进度窗口和主界面依然能够保持流畅响应，用户可以随时拖动、点击窗口，实时查看处理进度，而不会出现界面卡死或“未响应”的现象。

在处理进度窗口的实现中，每当后台线程完成一张图片的识别任务，就会通过信号机制通知主线程刷新进度条和状态文本。主线程收到信号后，立即更新“已识别”数量等信息，确保用户能够直观地看到每一步的处理进展。这种设计不仅提升了用户体验，也便于用户及时掌握批量处理的整体进度。

此外，系统还通过多线程实现了图像处理和数据操作的并行化。例如，图片的预处理、OCR识别、后处理等步骤可以在多个线程中同时进行，大大缩短了总处理时间。数据的读写操作也采用异步方式，避免了主线程阻塞，进一步提升了系统的响应速度。

资源管理方面，系统遵循内存管理、处理效率、响应时间和系统稳定性等原则，合理分配和释放内存资源，优化算法性能，减少用户等待时间。多线程的引入不仅提升了并发处理能力，还通过合理的线程调度和资源分配，保证了系统在长时间运行下的可靠性和稳定性。整体而言，这些优化措施确保了系统能够高效、稳定地运行，满足大批量医学图像自动识别和处理的实际需求。

---

### 2.4.6 项目打包成exe的相关技术


本项目采用了PyInstaller作为主要的打包工具。PyInstaller能够将Python脚本及其所有依赖（包括第三方库、资源文件、动态链接库等）打包成一个独立的可执行文件（.exe），用户无需安装Python环境即可直接运行。PyInstaller的优势在于支持绝大多数常见的Python库（如PyQt6、opencv-python、pytesseract、Pillow、openpyxl等），能够将所有依赖打包为单文件（--onefile）或单目录（--onedir）模式，并支持自定义资源文件、图标、数据文件的打包和路径管理，具有良好的跨平台兼容性。

在打包流程与配置方面，项目充分利用了PyInstaller的spec文件机制。spec文件是一个Python脚本，描述了打包过程中的所有细节，包括入口脚本路径、依赖的资源文件和数据文件（如mu_ban、lin_shi、results等文件夹）、输出目录（如dist/）、可执行文件名称、图标、窗口模式等。针对不同的功能模块（如识别方案编辑、OCR识别），项目分别编写了独立的spec文件，确保每个exe都能正确找到和使用所需的资源文件夹。

项目中有大量的配置文件、模板、临时数据和结果输出目录（如mu_ban、lin_shi、results）。在spec文件和打包命令中，通过--add-data参数或spec文件的datas字段，将这些文件夹一同打包到exe同目录下，保证exe运行时能够直接访问和读写这些数据。通过合理配置spec文件和打包参数，可以将多个文件夹一同包含在打包结果中，保证项目的完整性和可移植性。对于有多个功能入口的项目，可以分别打包为多个exe，互不干扰。

为简化打包流程，项目中编写了自动化脚本（如build.py、build_ocr.py），调用PyInstaller的API或命令行接口，自动完成打包、输出、清理临时文件等操作。这样，开发者只需运行一条命令即可完成整个打包流程，极大提升了开发效率和可维护性。

在路径与资源管理方面，项目通过判断sys.frozen属性，自动适配运行路径，无论是在源码环境还是exe环境下，都能正确定位到mu_ban、lin_shi、results等资源文件夹。这种路径适配技术保证了打包后的程序能够在任意目录下独立运行，不依赖于原始开发环境。

需要注意的是，打包时需确保所有依赖库已正确安装，且与Python版本兼容。对于如Tesseract-OCR等外部依赖，需在用户环境中提前安装并配置好环境变量。打包为--onefile模式时，首次运行会有解压延迟，属于正常现象。打包时还要注意不要让PyInstaller清空dist目录下已有的重要数据文件夹。

打包后，dist目录下会有exe文件和所需的mu_ban、lin_shi、results等文件夹，用户只需双击exe即可完成识别方案编辑、批量识别和结果保存等全流程操作，无需关心底层实现和依赖配置。

综上所述，本项目通过PyInstaller及其spec文件、自动化打包脚本、路径适配和资源管理等技术，实现了Python项目到Windows可执行文件的无缝转换。用户体验极大提升，部署和分发变得简单高效，极大方便了实际应用和推广。


---

# 3. 系统设计与实现


## 3.1 系统设计原则和需求分析


在系统开发过程中，系统严格遵循软件工程原则，采用系统化的开发方法确保系统的质量和可靠性。首先进行需求分析阶段，系统根据角膜地形图OCR识别的实际需求进行设计。通过深入分析用户需求，确定了系统的核心功能，包括图像处理、文本识别、结果导出等。在图像处理方面，系统需要支持多种图像格式的读取和处理，实现图像预处理、增强和分割等功能；在文本识别方面，系统需要支持多种OCR引擎，实现高精度的文字识别；在结果导出方面，系统需要支持多种格式的结果保存和导出，方便用户进行后续分析和使用。

然后进入系统设计阶段，采用模块化设计方法，将系统划分为多个功能模块，并定义模块间的接口。系统主要划分为图像处理模块、OCR识别模块、用户界面模块和数据管理模块。图像处理模块负责图像的预处理、增强和分割等操作，使用OpenCV库实现各种图像处理算法；OCR识别模块支持多种OCR引擎，实现文本识别功能，并提供预处理和后处理方案配置；用户界面模块使用PyQt6构建图形用户界面，包括图片标注界面、OCR方案编辑界面、识别结果显示界面等；数据管理模块通过DataManager类统一管理所有数据操作，实现数据的存储、读取和更新。每个模块都有明确的职责和接口定义，确保模块间的低耦合和高内聚。

接着进行代码实现阶段，使用Python语言实现，采用面向对象编程方式。系统使用类来组织代码，每个类都有清晰的职责和接口。例如，ImageWindow类负责图片显示和尺寸调整，OCREditWindow类负责OCR方案编辑，DataManager类负责数据管理。代码实现过程中注重代码的可读性和可维护性，使用JSDoc风格的注释详细说明每个类和方法的用途和参数。同时，系统实现了完整的错误处理机制，包括数据验证、异常捕获和用户提示，确保系统的可靠性。

最后进行测试验证阶段，系统实现了多层次的测试机制。在单元测试层面，对每个模块的功能进行独立测试，确保模块的正确性；在集成测试层面，测试模块间的接口和交互，确保系统的整体功能；在系统测试层面，测试系统的性能和稳定性，确保系统能够满足用户需求。系统还实现了完整的错误处理机制，包括数据验证、异常捕获和用户提示，确保系统的可靠性。例如，在保存数据时进行数据验证，确保必要字段不为空；在文件操作时进行异常捕获，防止系统崩溃；在用户操作时提供友好的提示信息，帮助用户理解和解决问题。

这种系统化的开发方法确保了系统的质量和可维护性，为用户提供了稳定可靠的服务。通过严格的需求分析、模块化的系统设计、规范的代码实现和全面的测试验证，系统不仅实现了预期的功能，还具有良好的可扩展性和可维护性，能够满足用户不断变化的需求。

---

## 3.2 系统结构设计（类图）



![[project_class_diagram.png]]


本项目旨在实现对角膜地形图等医学影像的自动化识别与信息提取。系统采用模块化、面向对象的设计思路，将整体功能划分为“编辑标注模块”和“识别处理模块”两大部分，并通过统一的数据管理机制实现各环节的数据流转和解耦。这样的架构既支持灵活的人工标注与方案编辑，也支持批量自动识别和结果可视化，便于后续扩展和维护。

在系统的核心中，DataManager类承担着数据中枢的角色。它负责所有数据的持久化、读取和全局变量管理。系统中所有与图片、标注、判别方案、OCR方案等相关的数据，均通过DataManager进行统一管理。通过以“别名+脚本名”为索引，DataManager实现了多脚本、多阶段的数据协作。这种设计极大地降低了各模块之间的耦合度，使得每个功能窗口都可以专注于自身业务逻辑，而无需关心底层数据的存储细节。

编辑标注模块由多个窗口类组成。ImageWindow负责图片的拖拽导入、尺寸调整和别名保存，用户可通过该窗口将原始图片导入系统，并为其指定唯一别名和显示尺寸，为后续标注和识别打下基础。TypeSchemeWindow用于编辑和保存图片类型判别的自定义方案，每个图片别名都可以有独立的判别逻辑，极大提升了系统的灵活性和适应性。ShowImageWindow提供图片标注功能，支持用户以不同类型在图片上画框，标注框的坐标、类型等信息都被保存，作为后续OCR识别的区域依据。OCREditWindow和BasicTypeEditWindow分别针对单个图片别名和全局基础类型，允许用户编辑OCR引擎选择、预处理和后处理方案，从而根据不同图片类型灵活调整识别策略。

识别处理模块则聚焦于批量图片的自动化处理。DropWindow负责批量图片的拖拽导入和收集，用户可将待识别图片或文件夹批量拖入，系统自动收集所有图片，准备进入识别流程。ResultOverlayWindow负责识别结果的可视化展示，支持在图片上叠加显示OCR识别内容，便于用户直观核查识别效果。ProgressWindow则负责各阶段（图片复制、类型判别、OCR识别）的进度展示，提升用户体验，便于监控批量处理流程。

系统的数据流转设计方面，用户通过ImageWindow导入图片，系统记录尺寸和别名。随后可在TypeSchemeWindow编辑类型判别方案，在ShowImageWindow进行区域标注，在OCREditWindow和BasicTypeEditWindow配置OCR方案。所有数据均通过DataManager统一存储和读取。批量识别流程中，用户通过DropWindow批量导入待识别图片，系统自动调用类型判别、区域分割、OCR识别等流程，识别结果通过ResultOverlayWindow可视化，处理进度由ProgressWindow实时反馈。

这种设计的最大亮点在于高度模块化和灵活的数据管理。每个窗口/功能点均为独立类，职责单一，便于维护和扩展。通过DataManager实现多脚本、多阶段的数据协作，支持全局和局部数据的灵活管理。系统既支持用户自定义判别、标注、识别方案，也支持批量自动化处理，满足多样化需求。拖拽导入、可视化标注、进度反馈等设计，极大提升了易用性和交互体验。新增图片类型、OCR引擎、后处理逻辑等，只需扩展相应窗口和配置，无需重构整体架构。

综上所述，本项目通过类结构和模块划分，实现了从图片导入、标注、方案编辑到批量识别、结果可视化的完整闭环。系统设计兼顾灵活性、可扩展性和易用性，为后续功能拓展和算法升级提供了基础。类图不仅反映了当前的实现结构，也为团队协作和文档说明提供了直观的参考依据。


---

## 3.3 系统运行流程设计（时序图）


### 3.3.1 识别方案编辑模块



![[bian_ji模块新版时序图.png]]



本项目的“识别方案编辑模块”是整个角膜地形图OCR系统的前端环节，承担着图片数据的导入、类型判别方案的编辑、识别区的人工标注以及新类型处理方案的灵活配置等任务。该模块的设计充分体现了“数据驱动、用户友好、可扩展性强”的理念，为后续的自动化识别流程打下了坚实基础。


识别方案编辑模块由多个功能窗口组成，每个窗口各司其职，协同完成识别方案的全流程编辑。其主要流程如下：


1. 图片导入与尺寸调整

用户通过“输入图片及调整尺寸的窗口”（pkl1.py）将原始图片拖拽导入系统。窗口支持图片的自适应显示和尺寸调整，用户可多次调整，直至满意为止。确认后，系统会为该图片分配唯一别名，并将标准尺寸等信息通过DataManager保存到pkl文件中。这一步确保了后续所有操作都以标准化的图片数据为基础，避免了尺寸不一致带来的识别误差。

1. 类型判别方案编辑

紧接着，系统自动启动“编辑类型判别方案的窗口”（pkl2.py）。该窗口会从pkl文件中读取并显示类型判别方案模板，用户可在文本框中编辑、测试判别逻辑。系统支持多次编辑和准确率测试，确保判别方案的科学性和有效性。用户确认后，判别方案被保存到pkl文件，为后续的自动化分类提供依据。

1. 识别区划分与标注

完成类型判别方案后，系统进入“编辑识别区划分方案的窗口”（pkl3.py）。该窗口支持用户在图片上以不同类型画框，进行识别区的人工标注。用户可通过鼠标操作创建、撤销、清空识别区，并通过类型选择按钮为每个框指定类型。所有标注信息（包括框的坐标、类型等）都通过DataManager保存到pkl文件，为后续OCR识别提供精确的区域划分。

2. 新类型处理方案编辑

如果用户在标注过程中定义了新的识别区类型，系统会自动启动“编辑新类型处理方案的窗口”（pkl4.py）。该窗口允许用户为新类型配置专属的预处理、OCR引擎选择和后处理方案，并支持测试识别准确率。用户确认后，所有处理方案被保存到pkl文件，确保新类型也能被后续流程正确识别和处理。

3. 基础类型处理方案编辑（可选）

系统还支持通过“编辑基础类型处理方案的窗口”（pkl5.py）对全局基础类型（如类型1~4）进行统一的OCR方案配置。用户可随时进入该窗口，对常见类型的处理逻辑进行批量编辑和优化，进一步提升系统的灵活性和效率。




整个识别方案编辑模块的数据流转均通过DataManager实现。无论是图片尺寸、类型判别方案、识别区标注还是处理方案，所有数据都以结构化方式存储在pkl文件中。各功能窗口通过DataManager读写数据，实现了高度解耦。这种设计不仅便于各模块独立开发和维护，也为后续功能扩展（如增加新类型、新处理逻辑）提供了极大便利。



模块设计高度重视用户体验。所有窗口均支持多次操作、实时反馈和结果预览。类型判别方案和新类型处理方案窗口均支持测试功能，用户可在编辑过程中即时验证方案效果。识别区标注窗口支持撤销、清空、类型切换等便捷操作，极大提升了标注效率和准确性。所有操作均有明确的保存、关闭和反馈机制，确保用户操作的可控性和安全性。



识别方案编辑模块采用插件化、配置化设计。无论是类型判别逻辑、识别区划分，还是OCR引擎和处理方案，都可以通过前端窗口灵活配置和扩展。系统支持多种OCR引擎的无缝切换，支持自定义前后处理逻辑，便于适应不同场景和需求。所有核心逻辑均与数据、配置解耦，极大降低了维护成本。



识别方案编辑模块不仅为后续的自动化识别流程提供了标准化、结构化的数据基础，还通过灵活的配置机制确保了系统的可持续演进。所有编辑结果均以别名为索引，存储在统一的pkl文件中，便于后续批量识别、结果统计和模型优化。



综上所述，识别方案编辑模块通过清晰的模块划分、灵活的数据管理、友好的用户交互和高度的可扩展性，实现了从图片导入、类型判别、区域标注到处理方案配置的完整闭环。系统设计兼顾了自动化处理与人工干预的灵活切换，为医学影像的批量智能识别提供了坚实的技术基础。新版时序图不仅反映了当前的实现结构，也为团队协作和后续功能拓展提供了直观的参考依据。


---

### 3.3.2 文字识别与保存模块


![[ocr模块新版时序图.png]]


本项目的OCR模块旨在实现对批量医学影像（如角膜地形图）图片的自动化分类、文字识别与结果输出。系统采用高度模块化、解耦的数据驱动设计，确保了流程的灵活性、可扩展性和易维护性。整个OCR模块的设计思路可以从“输入接收、图片分类、文字识别、结果展示与保存”四大环节进行梳理。



OCR流程的起点是“文件接收窗口”（ocr1.py），用户可以通过拖拽方式将单张图片或整个文件夹批量导入系统。窗口会自动筛选出后缀符合要求的图片文件，并将其统一复制到临时文件夹（lin_shi/dai_shi_bie），为后续处理做准备。这一设计不仅简化了用户操作，也保证了后续处理流程的数据一致性和隔离性。


图片接收完成后，系统自动启动“图片分类模块”（ocr2.py）。该模块首先从pkl文件（通过DataManager统一管理）中读取每种图片类型的判别方案，然后遍历临时文件夹中的所有图片，依次调用判别函数，对每张图片进行类型判断和标注。分类结果以字典形式传递给下游的文字识别模块。通过将判别逻辑与数据分离，系统支持用户自定义和动态调整分类规则，极大提升了适应性和可维护性。



分类完成后，进入“文字识别模块”（ocr3.py）。该模块首先根据图片类型，从pkl文件中读取对应的识别区划分方案和每个识别区的前处理、OCR、后处理方案。随后，模块对每张图片的每个识别区依次进行如下处理：

1. 预处理：对识别区图像进行如去噪、二值化、增强等操作，提高OCR准确率。

2. OCR识别：根据配置选择百度OCR或Tesseract等引擎进行文字识别。

3. 后处理：对识别结果进行格式化、去噪、正则提取等处理，得到最终结构化文本。

整个识别过程高度自动化，且支持用户自定义每一步的处理逻辑。所有处理方案均可通过前端窗口灵活编辑，极大提升了系统的灵活性和可扩展性。



识别结果生成后，系统并行启动“识别结果原位显示窗口”（ocr4.py）和“图片显示窗口”（ocr4.py）。图片显示窗口负责展示所有待识别图片，并支持用户通过按钮切换浏览。识别结果原位显示窗口则将OCR结果以叠加方式原位展示在图片上，便于用户直观核查识别效果。两窗口之间通过事件通知机制协同工作，保证图片与识别结果的同步切换。

用户在浏览过程中，可以随时点击保存按钮，触发“结果保存模块”（ocr6.py）。该模块会将当前所有识别结果嵌入预设的Excel模板，并保存到指定的结果目录（results），方便后续统计、分析和归档。保存完成后，系统会通过窗口反馈保存状态，提升用户体验。



整个OCR模块的数据流转均通过DataManager和pkl文件实现。无论是图片分类方案、识别区划分、处理方案还是识别结果，均以结构化方式存储在pkl文件中。各功能模块通过DataManager读写数据，实现了高度解耦。这样不仅便于各模块独立开发和维护，也为后续功能扩展（如增加新类型、新识别区、新处理逻辑）提供了极大便利。




在流程设计上，OCR模块大量采用并发和异步机制。例如，图片复制与分类、识别与结果展示等环节均可并行进行，极大提升了处理效率。用户界面友好，支持批量操作、进度反馈、原位核查和一键保存，极大提升了易用性和交互体验。



OCR模块的每个环节都采用插件化、配置化设计。无论是图片类型判别、识别区划分，还是OCR引擎和处理方案，都可以通过前端窗口灵活配置和扩展。系统支持多种OCR引擎的无缝切换，支持自定义前后处理逻辑，便于适应不同场景和需求。所有核心逻辑均与数据、配置解耦，极大降低了维护成本。



综上所述，本项目OCR模块通过清晰的模块划分、灵活的数据管理、友好的用户交互和高度的可扩展性，实现了从图片导入、分类、识别到结果展示与保存的完整闭环。系统设计兼顾了自动化处理与人工干预的灵活切换，为医学影像的批量智能识别提供了坚实的技术基础。时序图不仅反映了当前的实现结构，也为团队协作和后续功能拓展提供了直观的参考依据。


---

## 3.4 项目结构



项目根目录/
│
├── scripts/
│   ├── bian_ji/
│   │   ├── data_manager.py
│   │   ├── pkl1.py
│   │   ├── pkl2.py
│   │   ├── pkl3.py
│   │   ├── pkl4.py
│   │   ├── pkl5.py
│   │   └── pklmain.py
│   │
│   └── shi_bie/
│       ├── ocr1.py
│       ├── ocr2.py
│       ├── ocr3.py
│       ├── ocr4.py
│       ├── ocr5.py
│       ├── ocr6.py
│       ├── ocrmain.py
│       └── test_baidu_ocr.py
│
├── mu_ban/
│   ├── shared_data.pkl
│   ├── edit_shared_data.py
│   ├── view_pkl.py
│   └── baidu_ocr_key.txt
│
├── lin_shi/
│   └── dai_shi_bie/         # 临时图片子目录
│
├── results/                 # 识别结果输出目录
│
├── 原理图/
│   ├── class_diagram/
│   │   ├── generate_class_diagram.py
│   │   └── project_class_diagram.png
│   ├── bian_ji模块新版时序图.png
│   ├── ocr模块新版时序图.png
│   └── ...（其他流程图、时序图等）
│
└── README.md 及其它文档



项目根目录下包含了所有核心代码、配置、临时数据、结果输出、文档和可视化资源。整体结构清晰，便于开发、维护和协作。

---

### 3.4.1 scripts/


主程序代码目录，分为两个子模块，分别对应前端的“识别方案编辑”与后端的“OCR自动识别”：




#### 3.4.1.1 scripts/bian_ji/


识别方案编辑模块，主要负责模板图片的导入、类型判别方案编辑、识别区标注和处理方案配置。

- data_manager.py：统一的数据管理类，负责pkl文件的读写和数据的集中管理。

- pkl1.py：图片拖拽与尺寸调整窗口，负责图片导入和标准化。

- pkl2.py：类型判别方案编辑窗口，支持用户自定义图片类型判别逻辑。

- pkl3.py：识别区划分与标注窗口，支持人工画框、类型选择、撤销等操作。

- pkl4.py：新类型处理方案编辑窗口，配置新类型的OCR处理流程。

- pkl5.py：基础类型处理方案编辑窗口，统一配置常见类型的OCR方案。

- pklmain.py：前端主流程控制脚本，串联上述各窗口，实现完整的识别方案编辑流程。


---

#### 3.4.1.2 scripts/shi_bie/



OCR自动识别模块，负责批量图片的分类、文字识别、结果展示与保存。

- ocr1.py：文件/文件夹拖拽接收窗口，负责图片批量导入和临时存放。

- ocr2.py：图片分类（类型判别）模块，自动识别图片类型。

- ocr3.py：文字识别与处理模块，支持多种OCR引擎和自定义处理流程。

- ocr4.py：图片与识别结果原位显示窗口，支持图片浏览和识别结果可视化。

- ocr5.py：进度条与处理进度窗口，提升用户体验。

- ocr6.py：识别结果保存为Excel模块，便于结果归档和分析。

- ocrmain.py：后端主流程控制脚本，串联上述各模块，实现自动化识别全流程。

- test_baidu_ocr.py：百度OCR接口测试工具，便于调试和接口验证。

---

### 3.4.2 mu_ban/


模板与全局配置目录，用于存放全局数据文件、模板和密钥等配置。

- shared_data.pkl：所有识别方案、标注、处理配置等的统一数据文件。

- edit_shared_data.py：pkl文件的命令行编辑工具。

- view_pkl.py：pkl文件的可视化查看工具。

- baidu_ocr_key.txt：百度OCR接口密钥配置文件。

---

### 3.4.3 其他



lin_shi/

临时文件目录，用于存放待识别图片和中间文件。

- dai_shi_bie/：OCR模块处理时的临时图片存放子目录，保证数据隔离和流程安全。

---

 results/

识别结果输出目录，用于存放最终的识别结果文件（Excel表格），便于后续统计、分析和归档。

---

原理图/

项目文档与可视化目录，用于存放项目相关的类图、时序图、流程图等说明性图片和脚本。

- class_diagram/：类图脚本与生成的类图图片（如generate_class_diagram.py、project_class_diagram.png）。

- bian_ji模块新版时序图.png、ocr模块新版时序图.png：新版时序图、流程图等。

- 其他流程图、时序图等文档图片。

---

README.md 


项目说明文档，用于介绍项目背景、功能、安装方法、使用说明等，便于新成员快速上手和团队协作。

---

### 3.4.4 打包成.exe后



dist/
│
├── 测试图片/           # 存放用于测试的原始图片（可选，便于用户体验和演示）
│
├── 原理图/             # 存放项目相关的类图、时序图、流程图等文档图片
│
├── lin_shi/            # 临时文件夹，程序运行时用于存放中间图片数据
│
├── mu_ban/             # 模板与全局配置文件夹
│   ├── shared_data.pkl         # 识别方案、标注、处理配置等的统一数据文件
│   ├── edit_shared_data.py     # pkl文件命令行编辑工具（如有保留源码）
│   ├── view_pkl.py             # pkl文件可视化查看工具（如有保留源码）
│   └── baidu_ocr_key.txt       # 百度OCR接口密钥配置文件
│
├── results/            # 识别结果输出文件夹，保存最终的Excel等结果文件
│
├── 编辑识别方案.exe     # 前端环节的可执行文件（方案编辑/标注/配置）
│
├── 识别和保存.exe       # 后端环节的可执行文件（批量识别/结果保存）
│
└── README.md           # 项目说明文档，介绍使用方法、注意事项等



打包成exe后的项目结构充分体现了易用性、模块化和数据有序管理的设计理念。dist目录下包含了所有用户需要的功能入口、数据存储、临时文件、结果输出和文档资源。用户只需关注两个主要的可执行文件：“编辑识别方案.exe”和“识别和保存.exe”，分别对应前端的识别方案编辑与标注环节，以及后端的批量识别与结果保存环节。这样，用户可以根据实际需求灵活选择操作流程，无需关心底层的脚本实现和环境配置。

在数据和文件管理方面，项目将不同类型的数据分门别类地存放。mu_ban文件夹集中保存了所有全局配置、模板和数据文件，包括核心的shared_data.pkl（用于存储所有识别方案、标注和处理配置）以及baidu_ocr_key.txt（百度OCR接口密钥）。lin_shi文件夹作为临时文件目录，专门用于存放程序运行时产生的中间图片数据，保证了数据处理的隔离性和安全性。results文件夹则用于存放最终的识别结果文件（如Excel表格），方便用户后续查阅、统计和归档。

此外，dist目录下还包含了原理图和测试图片等辅助文件夹。原理图文件夹中存放着项目的类图、时序图、流程图等文档图片，帮助用户和开发者快速理解系统结构和使用流程。测试图片文件夹则为用户提供了便捷的测试素材，方便初次体验和演示软件功能。README.md文档则详细介绍了软件的功能、使用方法和注意事项，为用户提供了全方位的操作指引。

这种打包结构的最大优势在于“一键运行”和“数据与配置分离”。用户无需安装Python环境或手动配置依赖，只需双击exe文件即可完成识别方案的编辑、批量识别和结果保存等全流程操作。同时，所有配置和数据文件都集中管理，便于备份、迁移和维护。临时数据与最终结果分离，保证了数据的有序和流程的安全。文档和演示资源的齐全，也极大提升了用户的学习和使用体验。


---

# 4. 系统运行过程示例



本章通过实际操作演示，展示系统的主要功能、操作流程和运行效果

为使界面清楚，选择运行打包后的.exe文件，而不是在IDE中的python脚本文件

![[Pasted image 20250607041248.png]]

---

## 4.1 编辑识别方案



在运行之前清空了mu_ban文件夹中之前编辑的识别方案文件，所以现在运行程序时会首先创建一个空白pkl文件，然后第一步是编辑四种基本类型识别区的处理方案，并将结果存入此pkl文件


![[Pasted image 20250607043350.png]]

![[Pasted image 20250607041611.png]]

优先使用百度OCR引擎，它需要网络连接也消耗费用，但是识别准确率远远高于tesseractOCR，高到不需要设置预处理方案和后处理方案

一定要使用tesseractOCR的话，就可以在这个窗口里用python语法编辑预处理方案和后处理方案

![[Pasted image 20250607043923.png]]

以字典的格式保存进pkl文件里


编辑好这四个基本类型识别区的处理方案后，关闭窗口，自动进入下一环节

---


![[Pasted image 20250607043558.png]]

![[Pasted image 20250607043627.png]]

拖入模板图片，右下角会显示图片尺寸，可以拉动窗口边缘调整图片尺寸；点击保存按钮时会在.pkl文件中为这个图片创建一个id，将来会代表具有相同结构特征的一类图片；同时会将此时的图片尺寸保存进来，作为此类图片显示和处理时的标准尺寸

![[Pasted image 20250607044045.png]]

![[Pasted image 20250607043955.png]]

比如，截图中的这个san_tu就是某类图片的id，zise就是他们的标准尺寸

---

![[Pasted image 20250607044102.png]]

下一步就是为这类图片编辑判别方案，就是如何在将来批处理图像时输入的各种图片中识别出这类图片的方案；由用户自由发挥；也是用python语法写

![[Pasted image 20250607044247.png]]

点击保存后同样保存进pkl文件中、这个id的字典中


![[Pasted image 20250607044326.png]]

---

![[Pasted image 20250607044415.png]]

再下一步就是为这类图片选定文字识别区域；在左边窗口中鼠标左键点击-释放来画矩形框，然后在右边窗口中点击相应按钮来为此识别区设定类型；这里的四个类型对应于第一步的那四个基本类型


![[Pasted image 20250607044608.png]]

画框过程中如果有画错了的，可以键盘按b键撤销上一个框（back），或者按r键清除所有框（reset）；画框完成后键盘按c键进入下一阶段（continue）


会将画的这些框在此类图片标准尺寸下的坐标信息，以及框的类型信息保存进pkl文件中此类图片的字典中的相应位置；

![[Pasted image 20250607045200.png]]


并判断是否含有新类型的框，如果没有则程序结束，如果有则程序进入下一阶段，也是最后一阶段

![[Pasted image 20250607044910.png]]

---

![[Pasted image 20250607044918.png]]

最后一阶段是为新类型识别区编辑处理方案，与第一步的为基本类型识别区编辑处理方案的方法完全一致；

区别在于保存时不保存在pkl文件中的公共区域，而仅保存在此类型图片的字典中的相应位置

---

这一步也完成后，就实现了对一类图片的完整识别方案的编辑；之后就可以用字符识别程序来对此类图片进行自动批量处理了


目前默认版本的pkl文件中，包含四个基本类型识别区的处理方案、以及dan_tu、san_tu、si_tu三种类型图片的完整识别方案，

可以直接运行字符识别程序来对示例图片文件夹中的所有图片进行完全准确的自动批量识别和归类保存；

用户可以根据自己的需求，参照前述流程，设置对各种各样类型的图片的识别方案

---

## 4.2 对示例图片进行识别和保存


![[Pasted image 20250607045948.png]]

在运行识别和保存.exe时，要求已经有编辑好的pkl文件；

![[Pasted image 20250607050004.png]]

目前已经有对dan_tu、san_tu、si_tu三种类型图片的完整识别方案，接下来用这些类型的图片混在一起作为输入来演示字符识别程序的使用方法

---

![[Pasted image 20250607050241.png]]

运行程序时首先创建接收文件的窗口，鼠标将待识别的图片/包含图片的文件夹拖进去

![[Pasted image 20250607050327.png]]


之后会把这些图片复制到临时文件夹中，方便后续处理

---

之后会在后台自动执行，对临时文件夹中的每张图片，

先判断类型，再根据类型提取识别区，再对每个识别区根据类型进行相应的预处理、调用OCR引擎进行文字识别、对识别结果进行后处理，再将每个图片的各识别区的识别结果对应到这个图片上


![[Pasted image 20250607053607.png]]

这过程中会创建进度窗口，用户可以在这里看到目前的处理进度；这个窗口是只读的，除了最小化或者移动窗口位置，用户不能干涉这个处理过程

全部处理完成后窗口自动关闭，进入下一阶段


（这个截图是后来补的，为了省时间所以图片数量与下面的图片不一致；这不妨碍发挥演示功能）

---

![[Pasted image 20250607051539.png]]

自动创建两个窗口，其中一个按图片的标准尺寸显示图片（左），并在右下角显示当前图片在所有图片中的序号；

另一个窗口则将当前图片的所有识别区中的文字识别结果显示在同尺寸窗口的相应位置，这样方便用户检查是否有识别错误；

用户可以点击左边窗口左下角的按钮，切换到显示其他图片的信息；

用户可以点击保存按钮，将所有图片的识别结果，按规定的格式保存进新建的excel文件中

![[Pasted image 20250607052306.png]]

![[Pasted image 20250607052331.png]]

大致是这个样子，所有图片按图片类型归类，表格第一列中的每一行对应一类图片；

这一行在第二列中分成许多行，每一样对应这类型的一张图片；

然后从第三列开始，每一列对应于一种识别区的识别结果；一张图片中有多个同类型识别区时，每个识别区的识别结果之间会以序号分隔开；

自动处理好合适的列宽行高，不会发生显示不全的情况

---

## 4.3 系统性能测试小结


目前，对于测试图片的情况，可以做到图片类型判别的准确率为100%、文字识别的准确率为100%；

对于用户的真实使用情境，只要相应地设置好判别方案、识别区划分方案、识别区处理方案，想要实现很高的准确率的话，原则上没有不可逾越的障碍

---

# 5. 总结与展望

## 5.1 主要工作总结









---

## 5.2 创新点与不足










---

## 5.3 后续改进方向与展望







了解人类文明的全貌，理解每项技术在其中的意义



---

# 附录

## github链接

## 用户手册


![[Pasted image 20250606125154.png]]

---


## 相关文档

## 参考文献





---

## 致谢


感谢辅导员和教务老师

感谢导师

感谢家人朋友

感谢知乎用户John Hexa（现名q9adg）；开坛讲学，为我传道解惑

感谢知乎用户invalid s；帮我梳理好了设计算法进而开发产品的基本思路

感谢deepseek和cursor；以极广博的见闻、较好的分析能力，事无巨细不厌其烦地与我讨论各种各样的问题；这是我好多年前就渴望的

感谢z-library；方便快捷地提供许多书籍供我学习参考

感谢其他各软件和平台的开发团队；

感谢各文献和教科书的研究人员和编辑；


